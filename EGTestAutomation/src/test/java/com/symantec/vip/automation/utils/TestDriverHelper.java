package com.symantec.vip.automation.utils;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Properties;import org.apache.log4j.Logger;import com.symantec.vip.automation.restapi.RestClient;import com.symantec.vip.soapclient.VIPServicesSoapClient;public class TestDriverHelper {	public static Logger logger = Logger.getLogger("VIP_EG_AUTOMATION");	Properties properties = AutomationProperties.getInstance().GetAutomationProperties();	RestClient ent = new RestClient();	public static void clearFile(String fileLocation) {		try {			BufferedWriter bw = new BufferedWriter(new FileWriter(fileLocation));			bw.write("");			bw.flush();			bw.close();		} catch (IOException ioe) {			// You should really do something more appropriate here			ioe.printStackTrace();		}	}	public String[] splitTestStepAttribute(String testattributename) {		String[] splittedattributes = testattributename.split(":");		return splittedattributes;	}	public List<String> GetFilenames(String filepath) {		File fs = new File(filepath);		File[] listOfFiles = fs.listFiles();		List<String> filename = new ArrayList<String>();		for (int i = 0; i < listOfFiles.length; i++) {			if (listOfFiles[i].isFile()) {				filename.add(listOfFiles[i].getName());			}		}		return filename;	}	public boolean setTempOTP(Map<String, String> config) throws Exception {		boolean status = false;		String env = config.get("selected_env");		Map<String, String> usersListAutomationOrg;		Map<String, String> usersListAutomationDelegationOrg;		CloudUsersPropertiesHelper cuph = new CloudUsersPropertiesHelper();		logger.info("Enter: Generate temp OTP");		logger.info("VIP Environment is " + env);		usersListAutomationOrg = cuph.GetCommonPropertiesAndLastStringAsKey("cloud.automationorg.");		Iterator<Entry<String, String>> it = usersListAutomationOrg.entrySet().iterator();		while (it.hasNext()) {			Map.Entry<String, String> pairs = it.next();			VIPServicesSoapClient.generateTempOTP(pairs.getValue(), "494949", env);			it.remove();		}		usersListAutomationDelegationOrg = cuph.GetCommonPropertiesAndLastStringAsKey("cloud.automationdelegationorg.");		Iterator<Entry<String, String>> it1 = usersListAutomationDelegationOrg.entrySet().iterator();		while (it1.hasNext()) {			Map.Entry<String, String> pairs1 = it1.next();			VIPServicesSoapClient.GenerateTempOTPDelegationOrg(pairs1.getValue(), "494949", "production");			it1.remove();		}		return status;	}	public boolean setTempOTPForPerformanceTesting() throws Exception {		boolean status = false;		String env = "qa";		Map<String, String> usersListAutomationOrgQA;		CloudUsersPropertiesHelper cuph = new CloudUsersPropertiesHelper();		logger.info("Enter: Generate temp OTP for performance testing");		usersListAutomationOrgQA = cuph.GetCommonPropertiesAndLastStringAsKey("cloud.qa.automationorg.");		Iterator<Entry<String, String>> it = usersListAutomationOrgQA.entrySet().iterator();		while (it.hasNext()) {			Map.Entry<String, String> pairs = it.next();			VIPServicesSoapClient.generateTempOTP(pairs.getValue(), "494949", "qa");			it.remove();		}		return status;	}	public Map<String, String> getVIPServicesEnvironment(Map<String, String> configuration) throws Exception {		Map<String, String> envProperties = null;		AutomationPropertiesHelper tcph = new AutomationPropertiesHelper();		String selectedEnv = null;		if (configuration.get("selected_env") != null) {			selectedEnv = configuration.get("selected_env");		} else {			selectedEnv = tcph.GetPropertiesValueByKey("automation.vip.environment.selected_env");		}		switch (selectedEnv) {		case "production":			envProperties = tcph.GetCommonPropertiesAndLastStringAsKey("automation.vip.environment.production");			envProperties.put("selected_env", "production");			break;		case "qa":			envProperties = tcph.GetCommonPropertiesAndLastStringAsKey("automation.vip.environment.qa");			envProperties.put("selected_env", "qa");			break;		case "pv":			envProperties = tcph.GetCommonPropertiesAndLastStringAsKey("automation.vip.environment.pv");			envProperties.put("selected_env", "pv");			break;		default:			envProperties = tcph.GetCommonPropertiesAndLastStringAsKey("automation.vip.environment.production");			envProperties.put("selected_env", "production");			break;		}		return envProperties;	}	public String MakeURL(String protocol, String hostname, String port) {		String url = "";		if (protocol.equalsIgnoreCase("http")) {			url = protocol + "://" + hostname + ":" + port;		} else {			url = "https://" + hostname + ":" + port;		}		return url;	}	public void deleteFile(String path) {		try {			File file = new File(path);			if (file.delete()) {				logger.info("Deleted the file " + path);			} else {				logger.info("Failed to delete the file " + path);			}		} catch (Exception e) {			e.printStackTrace();		}	}	public boolean isSupportedVersion(HashMap<String, String> configuration) {		boolean out = true;		if (configuration.get("product_source_version") != null && configuration.get("minimum_eg_version") != null) {			String sourceVersion = configuration.get("product_source_version");			String minVersionRequired = configuration.get("minimum_eg_version");			minVersionRequired = minVersionRequired.replaceAll("[\\s.]", "");			sourceVersion = sourceVersion.replaceAll("[\\s.]", "");			int length = 0;			if (minVersionRequired.length() < sourceVersion.length()) {				length = minVersionRequired.length();			} else {				length = sourceVersion.length();			}			if (sourceVersion != null && minVersionRequired != null) {				if (sourceVersion.substring(0, Math.min(sourceVersion.length(), length)) != null && minVersionRequired.substring(0, Math.min(minVersionRequired.length(), length)) != null) {					if (Integer.valueOf(sourceVersion.substring(0, Math.min(sourceVersion.length(), length))) < Integer.valueOf(minVersionRequired.substring(0, Math.min(minVersionRequired.length(),						length)))) {						logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Source version " + configuration.get("product_source_version") + " is lower than the supported version "							+ configuration.get("minimum_eg_version") + ", so this TEST IS NOT APPLICABLE, SKIPPING AND PASSING this test");						return false;					}				}			}			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Source version " + configuration.get("product_source_version") + " is higher than the supported version "				+ configuration.get("minimum_eg_version") + ", so continuing with EXECUTION");		} else {			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "No specific version EG version dependancy for this test, so continuing with execution");		}		return out;	}}