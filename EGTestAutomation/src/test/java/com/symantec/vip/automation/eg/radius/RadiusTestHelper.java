package com.symantec.vip.automation.eg.radius;import java.io.PrintWriter;import java.io.StringWriter;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Properties;import org.apache.log4j.Logger;import org.testng.Assert;import com.symantec.vip.automation.VIPManagerTests;import com.symantec.vip.automation.mobilepush.AppiumThread;import com.symantec.vip.automation.restapi.RestClient;import com.symantec.vip.automation.utils.AutomationProperties;import com.symantec.vip.soapclient.VIPServicesSoapClient;public class RadiusTestHelper {	Logger logger = Logger.getLogger("VIP_EG_AUTOMATION");	Properties properties = AutomationProperties.getInstance().GetAutomationProperties();	VIPManagerTests vipManagerTests = new VIPManagerTests();	VIPServicesSoapClient soapClient = new VIPServicesSoapClient();	public void InvokeRadiusTests(Map<String, String> testParam) throws Exception {		RestClient ent = new RestClient();		Map<String, String> CurrentConfiguration = new HashMap<String, String>();		CurrentConfiguration = ent.PerformRemoteAction("CheckConfigurationStatus", testParam);		String bcTestReq = testParam.get("bc_mode");		String bcStatus = CurrentConfiguration.get("bc_mode_status");		TestBed tb = new TestBed();		Map<String, String> radiusResponse = new HashMap<String, String>();		String userPin = null;		String userPassword = null;		try {			if (testParam.get("enable-radius-ldap-mapping") != null) {				if (testParam.get("enable-radius-ldap-mapping").equalsIgnoreCase("true")) {					String rldapDetails = testParam.get("enable-radius-ldap-mapping") + testParam.get("radius_map_attribute") + "_" + testParam.get("ldap_mapping_attribute") + "_"							+ testParam.get("vendor_id") + "_" + testParam.get("vendor_attribute_type") + "_" + testParam.get("vendor_attribute_id") + "_" + testParam.get("ldap_radius_vendor_other");					testParam.put("enable-radius-ldap-mapping", rldapDetails.toLowerCase());				}			}			if (testParam.get("mode").equalsIgnoreCase("upo")) {				logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Setting user pin in the cloud to " + testParam.get("user_pin"));				soapClient.UpdateUser(testParam.get("user_name"), null, testParam.get("user_pin"), testParam.get("user_pin"), "active", false, testParam.get("selected_env"));			}			if (testParam.get("push-action") != null) {				if (testParam.get("push-action").equalsIgnoreCase("allow") || testParam.get("push-action").equalsIgnoreCase("deny")) {					AppiumThread at = new AppiumThread();					logger.info("Recoginized as PUSH scenario, so prefexing OS format to avoid conflict");					testParam.put("user_name", getOSPrefixedUsername(testParam));					logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Creating an appium thread"));					String serverContext = testParam.get("server_context").toLowerCase();					logger.info("Thread-" + Thread.currentThread().getId() + ": " + "server context was " + serverContext);					String deviceNo;					if (serverContext.contains("windows")) {						deviceNo = "1";					} else {						deviceNo = "1";					}					at.actOnAppium(deviceNo, "makedriver");					Thread t = new Thread(at);					t.setName("AT" + Thread.currentThread().getName());					t.start();					t.join();					logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Sending a validation request"));					at.actOnAppium(deviceNo, testParam.get("push-action").trim());					Thread th = new Thread(at);					th.setName("AT" + Thread.currentThread().getName());					th.start();				}			}			if (testParam.get("request_type") != null) {				logger.info("Thread-" + Thread.currentThread().getId() + ": " + "********** REQUEST TYPE IS " + testParam.get("request_type"));				if (testParam.get("request_type").equalsIgnoreCase("pinreset")) {					userPin = testParam.get("user_pin");					logger.info("Recoginized as PIN RESET scenario, so prefexing OS format to avoid conflict");					testParam.put("user_name", getOSPrefixedUsername(testParam));					logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Invoking a VIP SOAP call to set the flag 'pin force reset' for the user " + testParam.get("user_name"));					if (!soapClient.UpdateUser(testParam.get("user_name"), null, testParam.get("user_pin"), testParam.get("user_pin"), "active", true, testParam.get("selected_env"))) {						if (!soapClient.UpdateUser(testParam.get("user_name"), null, testParam.get("user_pin_new"), testParam.get("user_pin"), "active", true, testParam.get("selected_env"))) {							soapClient.UpdateUser(testParam.get("user_name"), null, null, testParam.get("user_pin"), "active", true, testParam.get("selected_env"));						}					}				} else if (testParam.get("request_type").equalsIgnoreCase("pwdmgmt")) {					testParam.put("user_name", getOSPrefixedUsername(testParam));					try {						tb.resetPassword(testParam);					} catch (Exception e) {						System.out.println(e);					}					tb.prepareForPasswordManagement(testParam);					long newPasswordExtention = new Date().getTime();					if (testParam.get("user_ldap_password_new").equals(testParam.get("user_ldap_password_confirm"))) {						testParam.put("user_ldap_password_new", testParam.get("user_ldap_password_new") + String.valueOf(newPasswordExtention));						testParam.put("user_ldap_password_confirm", testParam.get("user_ldap_password_confirm") + String.valueOf(newPasswordExtention));					}					Thread.sleep(5000);				}			}			logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("User name is: " + testParam.get("user_name").toString()));			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Invoking validation request");			radiusResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);			if (bcTestReq != null) {				if (bcTestReq.equalsIgnoreCase("auto")) {					if (bcStatus.equalsIgnoreCase("auto")) {						logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Sent a radius request and sleeping 3 minutes to allow validation server to switch to BC mode"));						Thread.sleep(180000);					}					logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Sending validation request by assuming that validation server is switched to BC mode"));					radiusResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);				}			}			if (testParam.get("request_type") != null && testParam.get("request_type").contains("info")) {				validateInfoModeMessage(testParam, radiusResponse);			} else {				ValidateTestResult(testParam, radiusResponse);				if (testParam.get("request_type") != null) {					logger.info("Thread-" + Thread.currentThread().getId() + ": " + "********** REQUEST TYPE IS " + testParam.get("request_type"));					if (testParam.get("request_type").equalsIgnoreCase("pinreset")) {						logger.info("Thread-" + Thread.currentThread().getId() + " Sending RADIUS Auth request with newly set PIN " + testParam.get("user_pin_new"));						if (testParam.get("push-action") != null) {							testParam.put("push-action", null);							testParam.put("user_otp", "494949");						}						testParam.put("request_type", "");						testParam.put("user_pin", testParam.get("user_pin_new"));						radiusResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);						ValidateTestResult(testParam, radiusResponse);					} else if (testParam.get("request_type").equalsIgnoreCase("pwdmgmt")) {						logger.info("Thread-" + Thread.currentThread().getId() + " Sending RADIUS Auth request with newly set Password " + testParam.get("user_ldap_password_new"));						if (testParam.get("push-action") != null) {							testParam.put("push-action", null);							testParam.put("user_otp", "494949");						}						testParam.put("push-action", null);						testParam.put("request_type", "");						userPassword = testParam.get("user_ldap_password");						testParam.put("user_ldap_password", testParam.get("user_ldap_password_new"));						radiusResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);						ValidateTestResult(testParam, radiusResponse);					}				}			}		} catch (Exception e) {			throw e;		} finally {			if (testParam.get("request_type") != null) {				if (testParam.get("request_type").equalsIgnoreCase("pinreset")) {					logger.info("Thread-" + Thread.currentThread().getId() + ": " + "PINReset: Invoking a VIP SOAP call to set the PIN back to the original PIN [" + userPin + "] for the user "							+ testParam.get("user_name"));					if (!soapClient.UpdateUser(testParam.get("user_name"), null, userPin, testParam.get("user_pin"), "active", false, testParam.get("selected_env"))) {						if (!soapClient.UpdateUser(testParam.get("user_name"), null, testParam.get("user_pin_new"), userPin, "active", false, testParam.get("selected_env"))) {							soapClient.UpdateUser(testParam.get("user_name"), null, null, userPin, "active", false, testParam.get("selected_env"));						}					}				} else if (testParam.get("request_type").equalsIgnoreCase("pwdmgmt")) {					logger.info("Thread-" + Thread.currentThread().getId() + ": " + " PWDManagement: resetting password of the user " + testParam.get("user_name") + " back to " + userPassword);					testParam.put("user_ldap_password", userPassword);					tb.resetPassword(testParam);				}			}		}	}	private void ValidateTestResult(Map<String, String> testParam, Map<String, String> radResponse) throws Exception {		RestClient ent = new RestClient();		int reasonCode = 0;		String reply = null;		String returnPacketType = null;		boolean pushFlag = false;		String expReturnCode = testParam.get("expected-return-code");		String expPacketType = testParam.get("expected-return-packet-type");		reply = radResponse.get("radius_reply_message");		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "reply message was:" + reply);		returnPacketType = radResponse.get("radius_packet_type");		String additionalMessageFromServer = radResponse.get("additional_message");		// System.out.println("Reply message is: " +reply);		int z = 0;		reasonCode = getReasonCode(reply, returnPacketType);		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Received the return code during 1st validation request was: " + reasonCode);		if (testParam.get("push-action") != null) {			if (testParam.get("push-action").equalsIgnoreCase("allow") || testParam.get("push-action").equalsIgnoreCase("deny")) {				pushFlag = true;			}		}		if (!expReturnCode.equalsIgnoreCase("22")) {			while (z < 3 && (reasonCode == 16 || reasonCode == 22)) {				logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Received error code 16 (Credential locked), Hence invoking enable credential method");				z = z + 1;				if (testParam.get("delegation_status") != null && testParam.get("delegation_status").contains("true")) {					vipManagerTests.unlockUser("manager.vip.symantec.com", getUserNameWithOutDomainFormat(testParam), "vipegautomationdelegation@gmail.com");				} else {					vipManagerTests.unlockUser(testParam.get("vip_manager_url"), getUserNameWithOutDomainFormat(testParam), "vipegautomation@gmail.com");				}				if (z == 2) {					if (testParam.get("delegation_status") != null && testParam.get("delegation_status").contains("true")) {						vipManagerTests.EnableCredential("manager.vip.symantec.com", testParam.get("credential_automationdelegationorg"), "vipegautomationdelegation@gmail.com");					} else {						vipManagerTests.EnableCredential(testParam.get("vip_manager_url"), testParam.get("credential_automationorg"), "vipegautomation@gmail.com");					}				}				radResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);				reply = radResponse.get("radius_reply_message");				logger.info("Thread-" + Thread.currentThread().getId() + ": " + "reply message was:" + reply);				returnPacketType = radResponse.get("radius_packet_type");				reasonCode = getReasonCode(reply, returnPacketType);			}		}		z = 0;		while (z < 1 && reasonCode == 12 && pushFlag) {			z = z + 1;			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Received error code 12 in PUSH FLOW, So trying to resume suspended credential via VIP Manager, retry no." + z);			vipManagerTests.resumeSuspendedPushCredential(testParam.get("vip_manager_url"), getUserNameWithOutDomainFormat(testParam), "vipegautomation@gmail.com");		}		z = 0;		while (z < 2 && reasonCode == 101 && !pushFlag) {			Thread.sleep(4000);			z = z + 1;			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Received error code 101 , Hence retring the request, retry no." + z);			radResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);			reply = radResponse.get("radius_reply_message");			returnPacketType = radResponse.get("radius_packet_type");			reasonCode = getReasonCode(reply, returnPacketType);		}		z = 0;		while (z < 3 && reasonCode == 48) {			Thread.sleep(4000);			if (testParam.get("push-action") != null) {				if (testParam.get("push-action").equalsIgnoreCase("allow") || testParam.get("push-action").equalsIgnoreCase("deny")) {					AppiumThread at = new AppiumThread();					logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Creating an appium thread"));					String serverContext = testParam.get("server_context").toLowerCase();					logger.info("Thread-" + Thread.currentThread().getId() + ": " + "server context was " + serverContext);					String deviceNo;					if (serverContext.contains("windows")) {						deviceNo = "1";					} else {						deviceNo = "2";					}					at.actOnAppium(deviceNo, "makedriver");					Thread t = new Thread(at);					t.setName("AT" + Thread.currentThread().getName());					t.start();					t.join();					logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Sending a validation request"));					at.actOnAppium(deviceNo, testParam.get("push-action").trim());					Thread th = new Thread(at);					th.setName("AT" + Thread.currentThread().getName());					th.start();				}			}			z = z + 1;			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Received error code 48 (Connectivity issue), Hence retring the request, retry no." + z);			radResponse = ent.PerformRemoteAction("InvokeRadiusCall", testParam);			reply = radResponse.get("radius_reply_message");			returnPacketType = radResponse.get("radius_packet_type");			reasonCode = getReasonCode(reply, returnPacketType);		}		logger.info("Thread-" + Thread.currentThread().getId() + ": " + ("Return code received from Validation server is " + reasonCode));		String message = GetReasonMessage(reasonCode);		Assert.assertEquals(returnPacketType, expPacketType, "Reason Code Received:" + reasonCode + ". Meaning: " + message + " Additional message was " + additionalMessageFromServer + "\n");		int expReturnCode1 = Integer.parseInt(expReturnCode);		Assert.assertEquals(reasonCode, expReturnCode1, "Reason: " + message + "\n");		validateRadiusLDAPMappingAttribute(testParam, radResponse);	}	private void validateRadiusLDAPMappingAttribute(Map<String, String> testParam, Map<String, String> radiusResponse) {		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Validating LDAP to Radius mapping response");		String radLDAPconfig = testParam.get("radius_map_attribute") + "_" + testParam.get("ldap_mapping_attribute") + "_" + testParam.get("vendor_id") + "_" + testParam.get("vendor_attribute_type")		+ "_" + testParam.get("vendor_attribute_id") + "_" + testParam.get("ldap_radius_vendor_other");		radLDAPconfig = radLDAPconfig.toLowerCase();		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Radius LDAP Config was "+radLDAPconfig);		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Radius response received from server was "+radiusResponse);		if (radLDAPconfig.contains("class")) {			if (radiusResponse.get("class") != null) {				if (radLDAPconfig.contains("memberof")) {					Assert.assertTrue(radiusResponse.get("class").contains("CN="), "Expected the content: CN= : AND received " + radiusResponse.get("class"));				} else if (radLDAPconfig.contains("userprincipalname")) {					Assert.assertTrue(radiusResponse.get("class").contains("@"), "Expected the content: @ : AND received " + radiusResponse.get("class"));				} else if (radLDAPconfig.contains("samaccount")) {					Assert.assertTrue(radiusResponse.get("class").contains("America"), "Expected the content: Samccount name of the groups : AND received " + radiusResponse.get("class"));				} else {					Assert.assertTrue(false, "Not in defined attribute set");				}			} else {				Assert.assertTrue(false, "No Class Content Received");			}		} else if (radLDAPconfig.contains("service-type")) {			Assert.assertTrue(radiusResponse.get("service_type") != null, "radius response returned service_type attribute returned null or not");		} else if (radLDAPconfig.contains("login-service")) {			Assert.assertTrue(radiusResponse.get("login_service") != null, "radius response returned login_service attribute returned null or not");		} else if (radLDAPconfig.contains("login-lat-service")) {			if (radiusResponse.get("login_lat_service") != null) {				if (radLDAPconfig.contains("displayname")) {					Assert.assertTrue(radiusResponse.get("login_lat_service").contains(testParam.get("user_name")), "Expected the content: username = : AND received "							+ radiusResponse.get("login_lat_service"));				} else if (radLDAPconfig.contains("displayname") && radiusResponse.get("login_lat_service").contains("bobby")) {					Assert.assertTrue(radiusResponse.get("login_lat_service").contains("bobby"), "Expected the content: Bobby = : AND received " + radiusResponse.get("login_lat_service"));				} else {					Assert.assertTrue(false, "Not in defined attribute set");				}			} else {				Assert.assertTrue(false, "No value returned in login_lat_service attribute");			}		} else if (radLDAPconfig.contains("login-lat-group")) {			if (radiusResponse.get("login_lat_group") != null) {				if (radLDAPconfig.contains("samaccountname")) {					Assert.assertTrue(radiusResponse.get("login_lat_group").contains(testParam.get("user_name")), "Expected the content: username = : AND received "							+ radiusResponse.get("login_lat_group"));				} else if ((radLDAPconfig.contains("samaccountname") || radLDAPconfig.contains("displayname")) && radiusResponse.get("login_lat_group").contains("bobby")) {					Assert.assertTrue(radiusResponse.get("login_lat_group").contains("bobby"), "Expected the content: bobby = : AND received " + radiusResponse.get("login_lat_group"));				} else {					Assert.assertTrue(false, "Not in defined attribute set");				}			} else {				Assert.assertTrue(false, "No value returned in login_lat_group attribute");			}		} else if (radLDAPconfig.contains("vendor-specific")) {			if (radiusResponse.get("vendor_specific") != null) {				if (radLDAPconfig.contains("memberof") && !radLDAPconfig.contains("cisco")) {					Assert.assertTrue(radiusResponse.get("vendor_specific").contains("CN="), "Expected the content: CN = : AND received " + radiusResponse.get("vendor_specific"));				} else if (radLDAPconfig.contains("cn")) {					Assert.assertTrue(radiusResponse.get("vendor_specific").contains("bobby"), "Expected the content: bobby : AND received " + radiusResponse.get("vendor_specific"));				} else if (radLDAPconfig.contains("displayname")) {					logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Checking displayName value");					Assert.assertTrue(radiusResponse.get("vendor_specific").trim().contains("bobby"), "Expected the content: bobby : AND received " + radiusResponse.get("vendor_specific"));				} else if (radLDAPconfig.contains("samaccount")) {					Assert.assertTrue(radiusResponse.get("vendor_specific").contains("America"), "Expected the content: Samccount name of the groups : AND received " + radiusResponse.get("class"));				} else {					Assert.assertTrue(false, "Not in defined attribute set");				}			} else {				Assert.assertTrue(false, "No value returned in vendor_specific attribute");			}		} else {			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Not configured to validate RADIUS TO LDAP MAPPING");		}	}	private String GetReasonMessage(int reasonCode) {		int code = reasonCode;		String reasonMessage = null;		switch (code) {		case 0:			reasonMessage = "Received Access-Accept from server";			break;		case 1:			reasonMessage = "No token is assigned to the user. \nSOLUTION: Assign a credential to the user or select another user.";			break;		case 3:			reasonMessage = "The first-factor validation failed. This is typically due to an incorrect username/password value. \nSOLUTION: Correct the username and/or password or select another user.";			break;		case 6:			reasonMessage = "The user store is not accessible. \nSOLUTION: Verify that the user store is accessible. ";			break;		case 7:			reasonMessage = "The user was not found in the user store. \nSOLUTION: Add the user or select another user.";			break;		case 8:			reasonMessage = "The password is incorrect. \nSOLUTION: Enter a valid user password.";			break;		case 11:			reasonMessage = "The user does not have an enabled credential. \n SOLUTION: Assign a credential to the user, or select another user.";			break;		case 12:			reasonMessage = "Second-factor validation failed. This is typically due to an incorrect security code \nSOLUTION: Enter a valid security code.";			break;		case 14:			reasonMessage = "The credential state is new. Credentials must be assigned to a user and in the enabled state to be used for validation. \n SOLUTION: Register and activate the credential before the user can use it for authentication.";			break;		case 15:			reasonMessage = "The credential is disabled. Credentials must be assigned to a user and in the enabled state to be used for validation \n SOLUTION: Enable the credential or choose one that is already enabled.";			break;		case 16:			reasonMessage = "The credential is Locked. Credentials must be assigned to a user and in the enabled state to be used for validation. \nSOLUTION:Unlock the credential or choose one that is already unlocked";			break;		case 17:			reasonMessage = "The credential is Inactive. Credentials must be assigned to a user and in the enabled state to be used for validation. \nSOLUTION:Activate the credential or choose one that is already active.";			break;		case 18:			reasonMessage = "The credential(s) are in mixed states, but none are enabled. Credentials must be assigned to a user and in the enabled state to be used for validation. \nSOLUTION: Enable a credential or choose one that is already enabled.";			break;		case 20:			reasonMessage = "This account or administrator does not have the correct permissions to perform this operation. \nSOLUTION: Retry the operation with the correct permissions.";			break;		case 22:			reasonMessage = "The credential operation you requested is not valid for this credential type. \nSOLUTION: Select an operation that is valid for this credential type.";			break;		case 23:			reasonMessage = "The user you selected does not exist in the VIP Authentication Service. \nSOLUTION: Select a valid user or add the user to the VIP Authentication Service (using the VIP Manager or VIP Web Service).";			break;		case 24:			reasonMessage = "Access PIN validation failed. This is typically due to an incorrect Access PIN. \nSOLUTION: Enter a valid Access PIN.";			break;		case 40:			reasonMessage = "Invalid Access challenge";			break;		case 41:			reasonMessage = "Error occured while fetching radius authorization attributes";			break;		case 42:			reasonMessage = "2nd factor failed in BC mode";			break;		case 43:			reasonMessage = "LDAP password expired in BC mode ON";			break;		case 44:			reasonMessage = "Password change failed due to password mismatch";			break;		case 45:			reasonMessage = "Password expired. Access-Challenge disabled.";			break;		case 46:			reasonMessage = "Access Challenge timeout";			break;		case 47:			reasonMessage = "Invalid Input";			break;		case 48:			reasonMessage = "Network connectivity issue to user services";			break;		case 49:			reasonMessage = "Info call failed when BC is ON";			break;		case 50:			reasonMessage = "Entered new PIN does not meet policy";			break;		case 100:			reasonMessage = "The credential type you selected is not supported for this account. \nSOLUTION: Select a valid credential type. ";			break;		case 101:			reasonMessage = "An internal error occurred. This may indicate that the VIP account you selected is not valid \nSOLUTION: Verify that you are accessing the correct VIP account. If this error persists, contact Technical Support.";			break;		case 150:			reasonMessage = "Access Challenge Timeout. User has not entered the security code within the configured access challenge timeout period \nSOLUTION: Educate your users to enter the security code when prompted.If this is a recurring problem for your users, increase the Access-Challenge time out period in the Validation Server";			break;		case 151:			reasonMessage = "Access Challenge buffer full. There are many pending responses to the Access-challenge thrown to the user. \nSOLUTION: Increase the watermark level or decrease the Access-Challenge time out period in the Validation Server configuration.";			break;		case 152:			reasonMessage = "Access Challenge User Limit exceeded. The user has sent multiple requests with valid user name and LDAP password, but has not responded to the access challenge. \nSOLUTION: Educate your users to enter the security code when prompted.If this is a recurring problem for your users, increase the number of request allowed per user in the configuration file";			break;		case 10000:			reasonMessage = "Radius server did not respond to the request";			break;		case 19999:			reasonMessage = "This scenario is not applicable, hence marking the result as NOT APPLICABLE";			break;		case 99999:			reasonMessage = "Test case was skipped due to incorrect test-bed configuration or test-bed preparation failed";			break;		case 13000:			reasonMessage = "Compared the return messages and marked the status as failed or passed based on the same";			break;		default:			reasonMessage = "Invalid Reason Code";			break;		}		return reasonMessage;	}	private void validateInfoModeMessage(Map<String, String> testParam, Map<String, String> radiusResponse) {		String expReturnCode = testParam.get("expected-return-code");		String expPacketType = testParam.get("expected-return-packet-type");		String reply = radiusResponse.get("radius_reply_message");		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "reply message was:" + reply);		String returnPacketType = radiusResponse.get("radius_packet_type");		if (radiusResponse != null && reply != null) {			Assert.assertEquals(returnPacketType.toLowerCase(), expPacketType.toLowerCase());			Assert.assertEquals(String.valueOf(getReasonCode(reply, returnPacketType)), expReturnCode);			if (testParam.get("bc_mode") != null && testParam.get("bc_mode").equalsIgnoreCase("disabled") && expReturnCode.equalsIgnoreCase("0")) {				String credentialId = reply.split("tokenid=")[1];				if (Boolean.valueOf(testParam.get("stacked_out"))) {					String[] credentialIds = credentialId.split(",");					for (int i = 0; i < credentialIds.length; i++) {						credentialId = credentialIds[i];						Assert.assertTrue(checkCredentialId(credentialId), "Credential ID " + credentialId + " is not in expected format");					}				} else {					Assert.assertTrue(checkCredentialId(credentialId), "Credential ID " + credentialId + " is not in expected format");				}				Assert.assertTrue(reply.contains("reason=0&tokenid="), "Reply message does not contain reason=0&tokenid=");			} else {				Assert.assertTrue(reply.equalsIgnoreCase("reason=" + getReasonCode(reply, returnPacketType)), "Reason code does not match reason=x format");			}		} else {			Assert.assertTrue(false, "Radius Response or reply message was null");		}	}	public String Stack2string(Throwable e) {		try {			StringWriter sw = new StringWriter();			PrintWriter pw = new PrintWriter(sw);			e.printStackTrace(pw);			return "------\r\n" + sw.toString() + "------\r\n";		} catch (Exception e2) {			return "bad stack2string";		}	}	public int getReasonCode(String reply, String returnPacketType) {		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Parsing REASON CODE from REPLY MESSAGE: " + reply);		int reasonCode = 10000;		if (returnPacketType != null) {			if (reply != null) {				if (reply.contains(";")) {					reply = reply.split(";")[0];				}				if (reply.contains("=") && (!reply.contains("&"))) {					String afterSpilit = reply.split("=")[1];					if (afterSpilit.toLowerCase().contains("pin")) {						reasonCode = Integer.parseInt(afterSpilit.split(" ")[0]);					} else if (!(afterSpilit.matches("[0-9]+"))) {						reasonCode = Integer.parseInt(afterSpilit.split(" ")[0].trim());					} else {						reasonCode = Integer.parseInt(afterSpilit);					}				} else if (reply.contains("&")) {					String afterSpilit = reply.split("&")[0];					afterSpilit = afterSpilit.split("=")[1];					if (afterSpilit.toLowerCase().contains("pin")) {						reasonCode = Integer.parseInt(afterSpilit.split(" ")[0]);					} else if (!(afterSpilit.matches("[0-9]+"))) {						reasonCode = Integer.parseInt(afterSpilit.split(" ")[0].trim());					} else {						reasonCode = Integer.parseInt(afterSpilit);					}					// reason=0&tokenid=; Success				} else {					logger.error("Thread-" + Thread.currentThread().getId() + ": " + "Reply message is not in specified format");					reasonCode = 10000;				}			} else {				reasonCode = 10000;			}		} else {			logger.error("Thread-" + Thread.currentThread().getId() + ": " + "Return Packet Type is NULL");		}		return reasonCode;	}	public String getOSPrefixedUsername(Map<String, String> testParam) {		String userName = null;		if (testParam.get("user_name").contains("windows") || testParam.get("user_name").contains("linux")) {			return testParam.get("user_name");		} else {			if (testParam.get("user_name").contains("\\")) {				logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Found the username format in <Domain\\user> ");				String domain = testParam.get("user_name").split("\\\\")[0];				String user = testParam.get("user_name").split("\\\\")[1];				if (testParam.get("server_context").contains("windows")) {					userName = domain + "\\" + "windows_" + user;				} else {					userName = domain + "\\" + "linux_" + user;				}			} else {				if (testParam.get("server_context").contains("windows")) {					userName = "windows_" + testParam.get("user_name");				} else {					userName = "linux_" + testParam.get("user_name");				}			}		}		logger.info("Thread-" + Thread.currentThread().getId() + ": " + "username after the the OS prefix is " + userName);		return userName;	}	public String getUserNameWithOutDomainFormat(Map<String, String> testParam) {		if (testParam.get("user_name").contains("\\")) {			logger.info("Thread-" + Thread.currentThread().getId() + ": " + "Found the username format in <Domain\\user> ");			return testParam.get("user_name").split("\\\\")[1].trim();		} else {			return testParam.get("user_name").trim();		}	}	public boolean checkCredentialId(String credentialId) {		boolean out = false;		logger.error("Thread-" + Thread.currentThread().getId() + ": " + "Checking credential ID " + credentialId);		if (credentialId.matches("^[A-Z]{4}\\d{8}$")) {			return true;		} else if (credentialId.contains("91")) {			if (credentialId.matches("^[A-Z]{0}\\d{12}$")) {				return true;			}		}		return out;	}}